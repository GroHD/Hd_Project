#!/usr/bin/env python
#-*- coding:utf-8 -*-

'''
 Name:HD
    列表是Python中最具灵活性的有序集合对象类型，与字符串不同的是,列表可以包含任何种类的对象:数字,字符串甚至其他列表。
    同样，与字符串不同，列表都是可变对象，他们都支持在远处修改的操作，可以通过制定的偏移值和分片，列表方法调用，阐述语句等方法来实现。
    下面总结常见的和具有代表性的列表对象操作：
'''
L=[]  #一个空列表
L1=[1,2,3,4] #四项：索引为0-3  值为 0-3
L2=['abc',['def','ghi']] #嵌套的子列表
L3=list('spam') # 可迭代项目的列表,连续的字符的列表  ['s','p','a','m']
print(L3)
L4=list(range(-4,4)) # 可迭代的项目的列表,连续的整数的列表
print(L4)
L1[0] #索引
obj = L2[1][1] #索引
print(obj)
obj1 = L4[1:5] #分片
print(obj1)
obj2 = len(L3) #求长度
print(obj2)

L5 = L1+L2 #合并
print(L5)
L6 = L1 *2 #重复
print(L6)
for x in L6:#迭代成员
    print(x)

b = 3 in L3 #是否存在
print(b)

L.append(1) #添加
L.extend([5,4,3])  #把参数中的列表合并到实例列表里
print(L)
L.insert(2,10) #插入到下标为2的位置插入一个10
print(L)
find_index = L.index(3) #查看参数3在列表中存在的位置返回的是下标,如果使用这个函数,查询某个值得时候不在列表中存在则报错,所以在使用之前最好判断下是否有这个值
print(find_index)
find_Count = L.count(2) # 查看参数2在列表中存在的个数,存在返回大于0,不存在返回0
print(find_Count)
L.sort() #进行排序
L.reverse()#反转

del L[1] # 删除元素中下标为1的值
print(L)
del L1[1:3]# 删除分片的值 [1,2,3,4] 那么删完之后 只剩[1,4]
print(L1)
L1.pop() #拿出第一个位置的值,然后把该值从列表中移除
print(L1)
L3.remove('s') #从列表中移除参数中的值,如果该值不存在则报错！
print(L3)

L4[1:3]=[] #把列表中下标为1-3但是不包括3的值从列表中移除
print(L4)
L4[1]=-3 #给列表固定的位置赋值
print(L4)
L4[1:3] =[9,8,7] #把列表中下标为1-3但是不包括3的值替换成等号右边的值,如果等号右边的值数量大于等号左边切片的的数量那么多余出来的值将插入到列表中
print(L4)
L7 = [x **2 for x in range(5)] #生成一个列表
print(L7)
L8 = list(map(ord,'abcd')) #把abcd 转成asicc 然后生成数组
print(L8)

r'''
   如果使用+操作符进行操作,+两边必须是相同类型的序列,否则运行时会出现类型错误。

   由于列表都是序列,对于列表而言,索引和分片操作与字符串中的操作基本相同。

   由于可以在列表中嵌套列表,有时需要将几次索引操作连在一起使用来深入到数据结构中去。
   例如一个二位列表
   matrix = [[1,2,3],[4,5,6],[7,8,9]]
    如果使用一次索引,会得到一整行（也就是嵌套的子列表）,如果使用两次索引,你将会得到某一行里的其中一项

    >>matrix[1]
    >>[4,5,6]
    >>matrix[1][1]
    >>5
    >>matrix[2][0]
    >>7
  由于列表是可变的,他们支持原处改变列表对象的操作。也就是说可以直接修改列表对象,而不会像字符串那样强迫你建立一个新的拷贝。

 索引与分片的赋值:
    当使用列表的时候,可以将它赋值给一个特定项(偏移)或整个片段（分片）来改变它的内容
    >>L=['spam','Spam','SPAN!']
    >>L[1] = 'Denve'
    >>L
    ['spam','Denve','SPAN!']
    >>l[0:2] =['eat','more']
    >>L
    ['eat','more','SPAM!']

    索引和分片的赋值都是在原来列表里修改,它们对列表进行直接修改,而不是生成一个新的列表作为结果
    上面最后一个赋值方法就是分片赋值，他仅仅用一步操作就能将列表的整个片段替换掉。
    分片赋值最好分成两步来理解：
        1.删除。删除等号左边指定的分片
        2.插入。将包含在等号右边对象中的片段插入纠纷片被删除的位置。

    如果分片赋值删除元素的数目和插入元素的数据不相等的时候,Python先会删除元素的目录,然后再删除元素的地方插入对应的元素。

    所以说分片赋值是一次性替换成整个片段,因为被赋值的序列长度不一定要与被赋值的分片的长度相匹配，所以分片赋值能够用来替换(覆盖),增长(插入)，缩短（删除）主列表。


    列表方法调用:
        与字符串相同,Python列表对象也支持特定类型方法调用，其中很多调用可以在原处修改主题列表：
            L.append('pease') 向列表L 尾部添加一个数据,Append  允许传入单一对象而不是列表。
            L.sort() 对列表进行排序处理,还可以通过传入关键字参数来修改排序行为，
            >>L =['abc','ABD','aBe']
            >>L.sort()
            >>L
            ['ABD','aBe','abc']
            >>L =['abc','ABD','aBe']
            >>L.sort(key=str.lower,reverse=True) 按小写进行排序,reverse 是倒序,默认的是正序
'''
L9 = ['Abc','ABD','aBe']
L9.sort()
print("默认排序:",L9)
L9.sort(reverse=True) #倒序
print("倒序:",L9)
L9.sort()
L9.sort(key=str.lower,reverse=True) #小写排序
print("小写排序:",L9)
#使用内置函数排序,使用内置函数排序会返回一个新的结果
L9.sort()
print("内置函数排序前：",L9)
L10 = sorted(L9,key=str.lower,reverse=True)
print("内置函数排序后：",L10)

'''
pop 和append 可以快速实现先进先出的堆栈结构，列表的末端作为对战的顶端
'''
L11 = [] #空队列
L11.append(1) #进队列
L11.append(2) #进队列
print(L11)
obj3 = L11.pop() #出栈
print(obj3,L11)
'''
    pop方法也能够接受某一个即将删除并返回的元素的偏移量(默认是最后一个)，这一个偏移量是可选的。
    其它方法:
        remove 删除某个元素
        insert 在偏移处插入某元素
        index 查找某元素的偏移值
'''
L11=['1','2','3']
print(L11.index('3')) #找到某个值得偏移量,不存在报错
L11.insert(2,'sel') #在偏移量位置插入一个值
print(L11)

L11.remove('2') #删除某个值
print(L11)

'''
    其他列表操作方法:
        由于列表是可变的,可以用del 语句在远处删除某项或某片段
        del L11[1] 删除偏移量为1的值
        del L11[1:]  删除偏移量从1开始之后的所有的值
    因为分片赋值是删除外加插入操作,也可以通过将空列表赋值给分片来删除列表片段(L11[:] = [])。
    Python会删除左侧的分片,然后什么也不插入。
'''





