#!/usr/bin/env python
#-*- coding:utf-8 -*-
'''
2017-02-28 11:23:20
HD
    元祖由简单的对象组构成，元祖与列表非常相似,只不过元祖不能在原处修改，并且通常写成圆括号中的一项。

    建议在元祖关闭圆括号之前加一个逗号来表示这是一个元祖,因为在一些情况下如果没有后面的逗号则不会构成元祖
    例:
        T = (4)  如果不加逗号这就是一个数字
        T = (4,) 这就是一个元祖

元祖基本上就像一个不可改变的列表。就像列表一样,元祖是序列,但是它具有不可变性和字符串类似
语法:
    T = (1,2,3,4) 创建有四个元素的元祖

'''
T2 = ()  #空元祖
T3 = (0,) #单个元素的元祖
T4 = (0,'Ni',1.2,3) #四个元素的元祖
T5 = 0,'Ni',1.2,3 #另一种四个元素的元祖
T6 = ('abc',('def','ghi')) #嵌套元祖
T7 = tuple('spam')#一个可迭代的元祖
print(T7)
T7[0] #索引
T6[0][1] #索引的索引
T5[1:4] #分片
len(T2) #长度

T2 +T3 #合并
T2*3 #重复

#迭代
for x in T2:
    print(x)

T8 = [x**2 for x in T3]
print("T8:",T8)


T = (1,2,3,4)#创建一个有四个元素的元祖
T = T+(5,6) #向元祖中添加两个元素
print(T) #打印出元祖内容
#在3.0中,元祖还有两个专有的可调用方法,但它的专有方法不像列表所拥有的那么多

#元祖可以混合嵌套使用,但是无法无法使用变量名增加长元素数量或减少元素数量,因为元祖是不可变得
T1 = ('spam',3.0,[11,22,33],{"name":'hd',"age":22,"gender":'man'})
print(T1)

#元祖中只有两个方法
obj = T4.index('Ni') #找出参数所在元祖中的索引位置,如果不存在则报错,该方法有三个参数，后两个是可选的，分别是搜索开始的位置和结束的位置
obj =T4.index('Ni',1,2) #搜索的位置必须有对应的值存在，否则报错
print("三个参数：",obj)
print("Index:",obj)
obj = T4.count('Ni') #找出参数所在元祖中的个数,不存在返回0!
print("Count:",obj)

r'''
    元祖除了常量语法和列表，字符串不同以外，元祖的操作和字符串及列表是一致的，"+","*" 以及分片才做对应于元祖时,将返回新元祖,并且元祖不提供字符串，列表和字典中的方法。
    如果相对元祖进行排序,通常先得将它转换为列表并让元祖成为一个可变的对象,这样才可以获得排序方法调用的权限。
'''
    #例:
T9 = ('3','1','9','6','4','5')
print("Tuple ：",T9)
tmp = list(T)#将元祖转换为一个列表
print("list 排序前：",tmp)
sorted(tmp)#对列表进行排序
print("list 排序后：",tmp)
T9 = tuple(tmp)
print("Tuple：",T9)
r'''
    上面的例子,列表和元祖内置函数用来将对象转换为列表,之后返回一个元祖。这两个调用都会生成新的对象。
    列表解析也可用于元祖的转换。
'''
#例：
T10 =(1,2,3,4,5,6)
L = [x +10 for x in T10]
print(L)
r'''
    列表解析是名副其实的序列操作，他们总会创建新的列表，也可以用于遍历包括元祖，字符串以及其他列表在内的任何序列对象。
    列表解析甚至可以用在某些并非实际存储的序列之上，任何可遍历的对象都可以，包括自动逐行读取的文件。
'''
'''
可命名元祖:
    import collections
    Mytuple = collections.namedtuple('Mytuple',['x','y','z','u'])
    Obj = Mytuple(11,22,33,44)
    #相当于 x = 111  y = 22
    取值
    Obj.x #11
    Obj.y #22
    Obj.z #33
    Obj.u #44
'''



